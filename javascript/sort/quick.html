<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>bubble</title>
</head>

<body>
    <p>
        一趟快速排序的算法是：
        <br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；
        <br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
        <br> 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；
        <br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；
        <br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，
        <br> 使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i，
        <br> j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。
    </p>
</body>
<script>
    var arr = [],
        length = 10;

    for (var i = 0; i < length; i++) {
        var ran = Math.floor(Math.random() * 100);
        arr.push(ran);
    }
    console.log("产生随机数组为：");
    console.log(arr);

    function quick(arr) {
        // 当分治到一个元素的时候就直接返回
        if (arr.length <= 1) { 
            return arr; 
        }
        // 找pivot(基准) 可以直接采取arr[0],基准关系到效率，pivotIndex的值可以根据某种算法得到最优
        var pivotIndex = 0,
            pivot = arr[pivotIndex];
        // 把基准从原数组删除
        arr.splice(pivotIndex, 1);
        // 定义左右数组
        var left = [];
        var right = [];

        // 比基准小的放在left，比基准大的放在right
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] <= pivot) {
                left.push(arr[i]);
            }
            else {
                right.push(arr[i]);
            }
        }
        // 递归，一层一层合并上来成为最后的数组，记住合并基准
        return quick(left).concat([pivot], quick(right));
    }
    console.log("排序后数组为：");
    console.log(quick(arr));

</script>

</html>